"use strict";(self.webpackChunkphysical_ai_textbook=self.webpackChunkphysical_ai_textbook||[]).push([[531],{5587:function(n,e,i){i.r(e),i.d(e,{assets:function(){return a},contentTitle:function(){return l},default:function(){return h},frontMatter:function(){return o},metadata:function(){return s},toc:function(){return c}});var s=JSON.parse('{"id":"chapter-2/2-2-urdf-sdf-physics","title":"Converting URDF to SDF and Configuring Physics","description":"Master URDF-to-SDF conversion and tune physics parameters for realistic robot simulation","source":"@site/docs/chapter-2/2-2-urdf-sdf-physics.md","sourceDirName":"chapter-2","slug":"/chapter-2/2-2-urdf-sdf-physics","permalink":"/physical-ai-textbook/docs/chapter-2/2-2-urdf-sdf-physics","draft":false,"unlisted":false,"editUrl":"https://github.com/Bil4l-Mehmood/physical-ai-textbook/edit/main/docs/chapter-2/2-2-urdf-sdf-physics.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2,"sidebar_label":"Lesson 2.2: URDF/SDF & Physics","title":"Converting URDF to SDF and Configuring Physics","description":"Master URDF-to-SDF conversion and tune physics parameters for realistic robot simulation","duration":90,"difficulty":"Intermediate","hardware":["Ubuntu 22.04 LTS","ROS 2 Humble","Gazebo Harmonic"],"prerequisites":["Lesson 1.4: URDF/XACRO Basics","Lesson 2.1: Gazebo Fundamentals"]},"sidebar":"tutorialSidebar","previous":{"title":"Lesson 2.1: Gazebo Fundamentals","permalink":"/physical-ai-textbook/docs/chapter-2/2-1-gazebo-fundamentals"},"next":{"title":"Lesson 2.3: Sensors & Unity","permalink":"/physical-ai-textbook/docs/chapter-2/2-3-sensors-unity"}}'),t=i(4848),r=i(8453);const o={sidebar_position:2,sidebar_label:"Lesson 2.2: URDF/SDF & Physics",title:"Converting URDF to SDF and Configuring Physics",description:"Master URDF-to-SDF conversion and tune physics parameters for realistic robot simulation",duration:90,difficulty:"Intermediate",hardware:["Ubuntu 22.04 LTS","ROS 2 Humble","Gazebo Harmonic"],prerequisites:["Lesson 1.4: URDF/XACRO Basics","Lesson 2.1: Gazebo Fundamentals"]},l="Lesson 2.2: URDF/SDF & Physics Configuration",a={},c=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Part 1: URDF vs SDF for Simulation",id:"part-1-urdf-vs-sdf-for-simulation",level:2},{value:"Key Differences",id:"key-differences",level:3},{value:"URDF to SDF Conversion Process",id:"urdf-to-sdf-conversion-process",level:3},{value:"Part 2: Automatic URDF to SDF Conversion",id:"part-2-automatic-urdf-to-sdf-conversion",level:2},{value:"Method 1: Using <code>urdf_to_sdf</code> Tool",id:"method-1-using-urdf_to_sdf-tool",level:3},{value:"Method 2: Using Python Script",id:"method-2-using-python-script",level:3},{value:"Part 3: Enhanced SDF with Physics Parameters",id:"part-3-enhanced-sdf-with-physics-parameters",level:2},{value:"Complete Robot SDF with Physics Tuning",id:"complete-robot-sdf-with-physics-tuning",level:3},{value:"Part 4: Physics Parameter Tuning Guide",id:"part-4-physics-parameter-tuning-guide",level:2},{value:"Understanding Key Parameters",id:"understanding-key-parameters",level:3},{value:"Tuning Strategy for Different Robots",id:"tuning-strategy-for-different-robots",level:3},{value:"Part 5: Testing and Validation",id:"part-5-testing-and-validation",level:2},{value:"Simulation Validation Script",id:"simulation-validation-script",level:3},{value:"Hands-On Exercise",id:"hands-on-exercise",level:2},{value:"Step 1: Create Physics Test World",id:"step-1-create-physics-test-world",level:3},{value:"Step 2: Launch with Physics Validation",id:"step-2-launch-with-physics-validation",level:3},{value:"Step 3: Experiments",id:"step-3-experiments",level:3},{value:"Exercises",id:"exercises",level:3},{value:"Common Physics Issues &amp; Solutions",id:"common-physics-issues--solutions",level:2},{value:"Key Takeaways",id:"key-takeaways",level:2},{value:"Further Reading",id:"further-reading",level:2}];function d(n){const e={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.header,{children:(0,t.jsx)(e.h1,{id:"lesson-22-urdfsdf--physics-configuration",children:"Lesson 2.2: URDF/SDF & Physics Configuration"})}),"\n",(0,t.jsxs)(e.admonition,{title:"Lesson Overview",type:"info",children:[(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Duration"}),": 90 minutes | ",(0,t.jsx)(e.strong,{children:"Difficulty"}),": Intermediate | ",(0,t.jsx)(e.strong,{children:"Hardware"}),": Ubuntu 22.04 + ROS 2 Humble + Gazebo"]}),(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Prerequisites"}),": Lessons 1.4 and 2.1"]}),(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Learning Outcome"}),": Convert URDF to SDF and configure realistic physics for simulation"]})]}),"\n",(0,t.jsx)(e.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,t.jsx)(e.p,{children:"By the end of this lesson, you will be able to:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Understand URDF limitations for simulation"}),"\n",(0,t.jsx)(e.li,{children:"Convert URDF files to SDF format using tools"}),"\n",(0,t.jsx)(e.li,{children:"Add simulation-specific parameters to models"}),"\n",(0,t.jsx)(e.li,{children:"Configure inertia properties for accurate physics"}),"\n",(0,t.jsx)(e.li,{children:"Tune friction, damping, and contact parameters"}),"\n",(0,t.jsx)(e.li,{children:"Test and validate physics configurations"}),"\n",(0,t.jsx)(e.li,{children:"Optimize simulation stability and realism"}),"\n",(0,t.jsx)(e.li,{children:"Debug physics errors and instabilities"}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"part-1-urdf-vs-sdf-for-simulation",children:"Part 1: URDF vs SDF for Simulation"}),"\n",(0,t.jsx)(e.h3,{id:"key-differences",children:"Key Differences"}),"\n",(0,t.jsxs)(e.table,{children:[(0,t.jsx)(e.thead,{children:(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.th,{children:"Feature"}),(0,t.jsx)(e.th,{children:"URDF"}),(0,t.jsx)(e.th,{children:"SDF"})]})}),(0,t.jsxs)(e.tbody,{children:[(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:(0,t.jsx)(e.strong,{children:"Purpose"})}),(0,t.jsx)(e.td,{children:"Visualization + ROS 2 communication"}),(0,t.jsx)(e.td,{children:"Physics simulation"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:(0,t.jsx)(e.strong,{children:"Inertia Requirement"})}),(0,t.jsx)(e.td,{children:"Optional"}),(0,t.jsxs)(e.td,{children:[(0,t.jsx)(e.strong,{children:"Required"})," for accurate physics"]})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:(0,t.jsx)(e.strong,{children:"Friction"})}),(0,t.jsx)(e.td,{children:"Basic (single value)"}),(0,t.jsx)(e.td,{children:"Advanced (separate directions)"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:(0,t.jsx)(e.strong,{children:"Damping"})}),(0,t.jsx)(e.td,{children:"Not specified"}),(0,t.jsx)(e.td,{children:"Full support (linear + angular)"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:(0,t.jsx)(e.strong,{children:"Sensors"})}),(0,t.jsx)(e.td,{children:"Basic declaration"}),(0,t.jsx)(e.td,{children:"Full plugin integration"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:(0,t.jsx)(e.strong,{children:"Collision Mesh"})}),(0,t.jsx)(e.td,{children:"Simple geometries"}),(0,t.jsx)(e.td,{children:"Complex meshes supported"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:(0,t.jsx)(e.strong,{children:"Physics Engine"})}),(0,t.jsx)(e.td,{children:"Not specified"}),(0,t.jsx)(e.td,{children:"Engine-specific options"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:(0,t.jsx)(e.strong,{children:"Extensibility"})}),(0,t.jsx)(e.td,{children:"Limited"}),(0,t.jsx)(e.td,{children:"Plugins for custom behavior"})]})]})]}),"\n",(0,t.jsx)(e.h3,{id:"urdf-to-sdf-conversion-process",children:"URDF to SDF Conversion Process"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"URDF (From Lesson 1.4)"}),":"]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:["Defines ",(0,t.jsx)(e.strong,{children:"structure"})," (links & joints)"]}),"\n",(0,t.jsxs)(e.li,{children:["Specifies ",(0,t.jsx)(e.strong,{children:"inertia"})," (mass, moment of inertia)"]}),"\n",(0,t.jsxs)(e.li,{children:["Describes ",(0,t.jsx)(e.strong,{children:"appearance"})," (visual geometry)"]}),"\n"]}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"SDF (For Gazebo)"}),":"]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:["Adds ",(0,t.jsx)(e.strong,{children:"physics parameters"})," (friction, damping, contact)"]}),"\n",(0,t.jsxs)(e.li,{children:["Specifies ",(0,t.jsx)(e.strong,{children:"simulation properties"})," (solver settings)"]}),"\n",(0,t.jsxs)(e.li,{children:["Includes ",(0,t.jsx)(e.strong,{children:"sensor plugins"})," (camera, lidar, IMU)"]}),"\n",(0,t.jsxs)(e.li,{children:["Defines ",(0,t.jsx)(e.strong,{children:"actuator constraints"})," (effort, velocity limits)"]}),"\n"]}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"part-2-automatic-urdf-to-sdf-conversion",children:"Part 2: Automatic URDF to SDF Conversion"}),"\n",(0,t.jsxs)(e.h3,{id:"method-1-using-urdf_to_sdf-tool",children:["Method 1: Using ",(0,t.jsx)(e.code,{children:"urdf_to_sdf"})," Tool"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-bash",children:"# Install conversion tool\nsudo apt install ros-humble-urdf-to-sdf\n\n# Convert your URDF\nurdf_to_sdf input.urdf -o output.sdf\n\n# Verify conversion\ngazebo output.sdf\n"})}),"\n",(0,t.jsx)(e.h3,{id:"method-2-using-python-script",children:"Method 2: Using Python Script"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:"#!/usr/bin/env python3\n\"\"\"\nConvert URDF to SDF with custom physics parameters\n\"\"\"\n\nfrom urdf_parser_py.urdf import URDF\nimport xml.etree.ElementTree as ET\n\n\ndef urdf_to_sdf(urdf_file, output_file):\n    \"\"\"\n    Convert URDF file to SDF format\n\n    Args:\n        urdf_file: Path to input URDF\n        output_file: Path to output SDF\n    \"\"\"\n\n    # Parse URDF\n    robot = URDF.from_xml_file(urdf_file)\n\n    # Create SDF root\n    sdf_root = ET.Element('sdf', version='1.10')\n    world = ET.SubElement(sdf_root, 'world', name='converted_world')\n\n    # Add physics\n    physics = ET.SubElement(world, 'physics', type='ode')\n    ET.SubElement(physics, 'max_step_size').text = '0.001'\n    ET.SubElement(physics, 'real_time_factor').text = '1.0'\n    ET.SubElement(physics, 'real_time_update_rate').text = '1000'\n\n    # Add light\n    light = ET.SubElement(world, 'light', name='sun', type='directional')\n    ET.SubElement(light, 'pose').text = '0 0 10 0 0 0'\n    ET.SubElement(light, 'diffuse').text = '0.8 0.8 0.8 1'\n\n    # Convert robot to SDF model\n    model = ET.SubElement(world, 'model', name=robot.name)\n    ET.SubElement(model, 'pose').text = '0 0 0 0 0 0'\n\n    # Convert URDF links to SDF links\n    for link in robot.links:\n        sdf_link = ET.SubElement(model, 'link', name=link.name)\n\n        # Add inertial (required for physics)\n        if link.inertial:\n            inertial = ET.SubElement(sdf_link, 'inertial')\n            inertial_pose = ET.SubElement(inertial, 'pose')\n            inertial_pose.text = f\"{link.inertial.origin.xyz[0]} {link.inertial.origin.xyz[1]} {link.inertial.origin.xyz[2]} 0 0 0\"\n\n            mass = ET.SubElement(inertial, 'mass')\n            mass.text = str(link.inertial.mass)\n\n            inertia = ET.SubElement(inertial, 'inertia')\n            ET.SubElement(inertia, 'ixx').text = str(link.inertial.inertia.ixx)\n            ET.SubElement(inertia, 'iyy').text = str(link.inertial.inertia.iyy)\n            ET.SubElement(inertia, 'izz').text = str(link.inertial.inertia.izz)\n\n        # Add visual (from URDF)\n        if link.visual:\n            visual = ET.SubElement(sdf_link, 'visual', name='visual')\n            visual_pose = ET.SubElement(visual, 'pose')\n            visual_pose.text = f\"{link.visual[0].origin.xyz[0]} {link.visual[0].origin.xyz[1]} {link.visual[0].origin.xyz[2]} 0 0 0\"\n            # ... add geometry ...\n\n        # Add collision with friction\n        if link.collision:\n            collision = ET.SubElement(sdf_link, 'collision', name='collision')\n            collision_pose = ET.SubElement(collision, 'pose')\n            collision_pose.text = f\"{link.collision[0].origin.xyz[0]} {link.collision[0].origin.xyz[1]} {link.collision[0].origin.xyz[2]} 0 0 0\"\n            # ... add geometry and friction ...\n\n    # Convert joints\n    for joint in robot.joints:\n        sdf_joint = ET.SubElement(model, 'joint', name=joint.name, type=joint.type)\n        ET.SubElement(sdf_joint, 'parent').text = joint.parent.link\n        ET.SubElement(sdf_joint, 'child').text = joint.child.link\n        ET.SubElement(sdf_joint, 'pose').text = f\"{joint.origin.xyz[0]} {joint.origin.xyz[1]} {joint.origin.xyz[2]} 0 0 0\"\n\n        # Add axis\n        axis = ET.SubElement(sdf_joint, 'axis')\n        ET.SubElement(axis, 'xyz').text = f\"{joint.axis[0]} {joint.axis[1]} {joint.axis[2]}\"\n\n        # Add limits\n        limits = ET.SubElement(sdf_joint, 'axis')\n        if hasattr(joint, 'limit'):\n            ET.SubElement(limits, 'lower').text = str(joint.limit.lower)\n            ET.SubElement(limits, 'upper').text = str(joint.limit.upper)\n            ET.SubElement(limits, 'effort').text = str(joint.limit.effort)\n            ET.SubElement(limits, 'velocity').text = str(joint.limit.velocity)\n\n    # Write SDF\n    tree = ET.ElementTree(sdf_root)\n    tree.write(output_file, encoding='utf-8', xml_declaration=True)\n\n    print(f\"Converted {urdf_file} \u2192 {output_file}\")\n\n\nif __name__ == '__main__':\n    urdf_to_sdf('simple_robot.urdf', 'simple_robot.sdf')\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"part-3-enhanced-sdf-with-physics-parameters",children:"Part 3: Enhanced SDF with Physics Parameters"}),"\n",(0,t.jsx)(e.h3,{id:"complete-robot-sdf-with-physics-tuning",children:"Complete Robot SDF with Physics Tuning"}),"\n",(0,t.jsxs)(e.p,{children:["Create ",(0,t.jsx)(e.code,{children:"simple_robot_physics.sdf"}),":"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-xml",children:'<?xml version="1.0" ?>\n\x3c!-- Copyright (c) 2025 Physical AI Course\n     License: MIT\n     Target: Ubuntu 22.04 + ROS 2 Humble + Gazebo\n--\x3e\n<sdf version="1.10">\n  <world name="robot_physics_world">\n\n    \x3c!-- Physics Engine Configuration --\x3e\n    <physics name="physics" type="ode">\n      \x3c!-- Simulation timestep: smaller = more accurate but slower --\x3e\n      <max_step_size>0.001</max_step_size>\n\n      \x3c!-- Realtime factor: 1.0 = normal speed, 2.0 = 2x faster --\x3e\n      <real_time_factor>1.0</real_time_factor>\n\n      \x3c!-- Update rate: how often to publish states --\x3e\n      <real_time_update_rate>1000</real_time_update_rate>\n\n      \x3c!-- Gravity (m/s^2): Earth = -9.81 in z direction --\x3e\n      <gravity>0 0 -9.81</gravity>\n\n      \x3c!-- ODE Solver Settings --\x3e\n      <ode>\n        <solver>\n          \x3c!-- \'quick\' is faster but less accurate; \'world\' is more accurate --\x3e\n          <type>quick</type>\n\n          \x3c!-- Number of iterations for solver --\x3e\n          <iters>50</iters>\n\n          \x3c!-- Preconditioning iterations (0 = faster, 1 = more stable) --\x3e\n          <precon_iters>0</precon_iters>\n\n          \x3c!-- Successive Over-Relaxation: 1.3 = default, 1.0 = slower convergence --\x3e\n          <sor>1.400000</sor>\n        </solver>\n\n        \x3c!-- Contact and constraint settings --\x3e\n        <constraints>\n          \x3c!-- Constraint Force Mixing: higher = softer contacts --\x3e\n          <cfm>0.000000</cfm>\n\n          \x3c!-- Error Reduction Parameter: higher = faster stabilization --\x3e\n          <erp>0.200000</erp>\n\n          \x3c!-- Max velocity for contact correction (m/s) --\x3e\n          <contact_max_correcting_vel>100.000000</contact_max_correcting_vel>\n\n          \x3c!-- Contact surface layer depth (m) --\x3e\n          <contact_surface_layer>0.001000</contact_surface_layer>\n        </constraints>\n      </ode>\n    </physics>\n\n    \x3c!-- Lighting --\x3e\n    <light name="sun" type="directional">\n      <cast_shadows>true</cast_shadows>\n      <pose>0 0 10 0 0 0</pose>\n      <diffuse>0.8 0.8 0.8 1</diffuse>\n      <direction>-0.5 0.1 -0.9</direction>\n    </light>\n\n    \x3c!-- Ground Plane with Friction --\x3e\n    <model name="ground_plane">\n      <static>true</static>\n      <link name="link">\n        <collision name="collision">\n          <geometry>\n            <plane>\n              <normal>0 0 1</normal>\n              <size>100 100</size>\n            </plane>\n          </geometry>\n          \x3c!-- Ground friction --\x3e\n          <surface>\n            <friction>\n              <ode>\n                \x3c!-- Coefficient of friction (0.6 = rubber on concrete) --\x3e\n                <mu>0.6</mu>\n                \x3c!-- Second friction direction --\x3e\n                <mu2>0.6</mu2>\n                \x3c!-- Slip velocity threshold --\x3e\n                <slip1>0.001</slip1>\n                <slip2>0.001</slip2>\n              </ode>\n            </friction>\n            <contact>\n              \x3c!-- Soft contact parameters for stability --\x3e\n              <ode>\n                <soft_cfm>0.0</soft_cfm>\n                <soft_erp>0.2</soft_erp>\n              </ode>\n            </contact>\n          </surface>\n        </collision>\n        <visual name="visual">\n          <geometry>\n            <plane>\n              <normal>0 0 1</normal>\n              <size>100 100</size>\n            </plane>\n          </geometry>\n          <material>\n            <ambient>0.8 0.8 0.8 1</ambient>\n            <diffuse>0.8 0.8 0.8 1</diffuse>\n          </material>\n        </visual>\n      </link>\n    </model>\n\n    \x3c!-- Robot Model --\x3e\n    <model name="simple_robot_physics">\n      <pose>0 0 0.5 0 0 0</pose>\n\n      \x3c!-- Base Link --\x3e\n      <link name="base_link">\n        <inertial>\n          <mass>1.0</mass>\n          <inertia>\n            <ixx>0.01</ixx>\n            <iyy>0.01</iyy>\n            <izz>0.01</izz>\n          </inertia>\n        </inertial>\n        <visual name="visual">\n          <geometry>\n            <box>\n              <size>0.1 0.1 0.1</size>\n            </box>\n          </geometry>\n          <material>\n            <ambient>0.5 0.5 0.5 1</ambient>\n            <diffuse>0.5 0.5 0.5 1</diffuse>\n          </material>\n        </visual>\n        <collision name="collision">\n          <geometry>\n            <box>\n              <size>0.1 0.1 0.1</size>\n            </box>\n          </geometry>\n          <surface>\n            <friction>\n              <ode>\n                <mu>0.4</mu>\n                <mu2>0.4</mu2>\n              </ode>\n            </friction>\n          </surface>\n        </collision>\n      </link>\n\n      \x3c!-- Joint 1 with Dynamics --\x3e\n      <joint name="joint_1" type="revolute">\n        <parent>base_link</parent>\n        <child>link_1</child>\n        <pose>0 0 0.1 0 0 0</pose>\n        <axis>\n          <xyz>0 1 0</xyz>\n          \x3c!-- Joint damping: resists motion (b in F = -b*v) --\x3e\n          <dynamics>\n            <damping>0.1</damping>\n            \x3c!-- Friction: constant resistance to motion --\x3e\n            <friction>0.0</friction>\n          </dynamics>\n        </axis>\n        \x3c!-- Joint limits --\x3e\n        <limit>\n          <lower>-1.5708</lower>\n          <upper>1.5708</upper>\n          <effort>10</effort>\n          <velocity>1</velocity>\n        </limit>\n      </joint>\n\n      \x3c!-- Link 1 --\x3e\n      <link name="link_1">\n        <inertial>\n          <mass>0.5</mass>\n          <origin xyz="0 0 0.05"/>\n          <inertia>\n            <ixx>0.005</ixx>\n            <iyy>0.005</iyy>\n            <izz>0.001</izz>\n          </inertia>\n        </inertial>\n        <visual name="visual">\n          <origin xyz="0 0 0.05"/>\n          <geometry>\n            <cylinder>\n              <radius>0.02</radius>\n              <length>0.1</length>\n            </cylinder>\n          </geometry>\n          <material>\n            <ambient>0.2 0.2 0.8 1</ambient>\n            <diffuse>0.2 0.2 0.8 1</diffuse>\n          </material>\n        </visual>\n        <collision name="collision">\n          <origin xyz="0 0 0.05"/>\n          <geometry>\n            <cylinder>\n              <radius>0.02</radius>\n              <length>0.1</length>\n            </cylinder>\n          </geometry>\n          <surface>\n            <friction>\n              <ode>\n                <mu>0.4</mu>\n                <mu2>0.4</mu2>\n              </ode>\n            </friction>\n          </surface>\n        </collision>\n      </link>\n\n      \x3c!-- Joint 2 --\x3e\n      <joint name="joint_2" type="revolute">\n        <parent>link_1</parent>\n        <child>link_2</child>\n        <pose>0 0 0.1 0 0 0</pose>\n        <axis>\n          <xyz>0 1 0</xyz>\n          <dynamics>\n            <damping>0.1</damping>\n            <friction>0.0</friction>\n          </dynamics>\n        </axis>\n        <limit>\n          <lower>-1.5708</lower>\n          <upper>1.5708</upper>\n          <effort>10</effort>\n          <velocity>1</velocity>\n        </limit>\n      </joint>\n\n      \x3c!-- Link 2 (End Effector) --\x3e\n      <link name="link_2">\n        <inertial>\n          <mass>0.3</mass>\n          <origin xyz="0 0 0.05"/>\n          <inertia>\n            <ixx>0.003</ixx>\n            <iyy>0.003</iyy>\n            <izz>0.0005</izz>\n          </inertia>\n        </inertial>\n        <visual name="visual">\n          <origin xyz="0 0 0.05"/>\n          <geometry>\n            <cylinder>\n              <radius>0.015</radius>\n              <length>0.1</length>\n            </cylinder>\n          </geometry>\n          <material>\n            <ambient>0.8 0.2 0.2 1</ambient>\n            <diffuse>0.8 0.2 0.2 1</diffuse>\n          </material>\n        </visual>\n        <collision name="collision">\n          <origin xyz="0 0 0.05"/>\n          <geometry>\n            <cylinder>\n              <radius>0.015</radius>\n              <length>0.1</length>\n            </cylinder>\n          </geometry>\n          <surface>\n            <friction>\n              <ode>\n                <mu>0.4</mu>\n                <mu2>0.4</mu2>\n              </ode>\n            </friction>\n          </surface>\n        </collision>\n      </link>\n\n    </model>\n\n  </world>\n</sdf>\n'})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"part-4-physics-parameter-tuning-guide",children:"Part 4: Physics Parameter Tuning Guide"}),"\n",(0,t.jsx)(e.h3,{id:"understanding-key-parameters",children:"Understanding Key Parameters"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Damping"})," (Linear & Angular):"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"Force = -damping * velocity\nEffect: Dissipates energy over time (like air resistance)\nRange: 0.0 (no damping) to 1.0+ (heavy damping)\nRobot arm: 0.1 (light damping for smooth motion)\nHumanoid: 0.5+ (heavier damping for stability)\n"})}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Friction Coefficient (\u03bc)"}),":"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"Friction = \u03bc * Normal_Force\nEffect: Prevents sliding on surfaces\nCommon values:\n  - 0.1: Ice/slippery surface\n  - 0.4: Plastic on concrete\n  - 0.6: Rubber on concrete\n  - 1.0+: High-grip materials\n"})}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Error Reduction Parameter (ERP)"}),":"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"ERP = Fraction of error corrected per timestep\nEffect: How aggressively constraints are enforced\nRange: 0.0 (no correction) to 1.0 (full correction)\nValue: 0.2 (default, good balance)\nLower: More accurate but slower convergence\nHigher: Faster but may oscillate\n"})}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Constraint Force Mixing (CFM)"}),":"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{children:"CFM = Softness of constraints\nEffect: Allows slight constraint violations for stability\nRange: 0.0 (very stiff) to 0.1 (soft)\nValue: 0.0 (default, rigid constraints)\nHigher CFM: More flexible, slower convergence\n"})}),"\n",(0,t.jsx)(e.h3,{id:"tuning-strategy-for-different-robots",children:"Tuning Strategy for Different Robots"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Stable Robot (Low velocity, robust)"}),":"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-xml",children:"<damping>0.5</damping>        \x3c!-- Higher damping --\x3e\n<friction>0.8</friction>       \x3c!-- High friction --\x3e\n<erp>0.2</erp>                 \x3c!-- Standard ERP --\x3e\n<cfm>0.0</cfm>                 \x3c!-- Rigid constraints --\x3e\n<max_step_size>0.001</max_step_size>\n"})}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Fast Robot (High velocity, agile)"}),":"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-xml",children:"<damping>0.1</damping>         \x3c!-- Low damping --\x3e\n<friction>0.4</friction>       \x3c!-- Lower friction --\x3e\n<erp>0.5</erp>                 \x3c!-- Higher ERP for stability --\x3e\n<cfm>0.0</cfm>                 \x3c!-- Rigid --\x3e\n<max_step_size>0.0005</max_step_size>  \x3c!-- Smaller timestep --\x3e\n"})}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Humanoid Robot (Balanced, realistic)"}),":"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-xml",children:"<damping>0.3</damping>         \x3c!-- Moderate damping --\x3e\n<friction>0.6</friction>       \x3c!-- Standard friction --\x3e\n<erp>0.2</erp>                 \x3c!-- Standard ERP --\x3e\n<cfm>0.0</cfm>                 \x3c!-- Rigid --\x3e\n<max_step_size>0.001</max_step_size>\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"part-5-testing-and-validation",children:"Part 5: Testing and Validation"}),"\n",(0,t.jsx)(e.h3,{id:"simulation-validation-script",children:"Simulation Validation Script"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-python",children:"#!/usr/bin/env python3\n\"\"\"\nValidate physics simulation of robot\nCheck for common physics issues\n\"\"\"\n\nimport rclpy\nfrom rclpy.node import Node\nfrom gazebo_msgs.msg import ModelState, LinkState\nfrom geometry_msgs.msg import Twist\nimport math\n\n\nclass PhysicsValidator(Node):\n    \"\"\"Validate robot physics in Gazebo\"\"\"\n\n    def __init__(self):\n        super().__init__('physics_validator')\n\n        # Subscribers\n        self.model_states_sub = self.create_subscription(\n            ModelState,\n            '/gazebo/model_states',\n            self.model_states_callback,\n            10\n        )\n\n        self.link_states_sub = self.create_subscription(\n            LinkState,\n            '/gazebo/link_states',\n            self.link_states_callback,\n            10\n        )\n\n        self.initial_height = None\n        self.falling = False\n        self.get_logger().info('Physics validator initialized')\n\n    def model_states_callback(self, msg):\n        \"\"\"Monitor model states for physics validation\"\"\"\n        if 'simple_robot' not in msg.name:\n            return\n\n        idx = msg.name.index('simple_robot')\n        pose = msg.pose[idx]\n\n        # Check 1: Robot falls due to gravity\n        if self.initial_height is None:\n            self.initial_height = pose.position.z\n            self.get_logger().info(f'Initial height: {self.initial_height:.3f}m')\n\n        # Robot should fall in first seconds\n        if pose.position.z < self.initial_height - 0.3:\n            if not self.falling:\n                self.falling = True\n                self.get_logger().info('\u2705 Gravity working: Robot is falling')\n\n        # Check 2: Robot doesn't fall through ground (z > 0)\n        if pose.position.z < 0:\n            self.get_logger().error('\u274c PHYSICS ERROR: Robot penetrated ground!')\n\n        # Check 3: Robot velocity reasonable\n        vel_magnitude = math.sqrt(\n            msg.twist[idx].linear.x**2 +\n            msg.twist[idx].linear.y**2 +\n            msg.twist[idx].linear.z**2\n        )\n        if vel_magnitude > 10.0:  # > 10 m/s is too fast\n            self.get_logger().warn(f'\u26a0\ufe0f  High velocity: {vel_magnitude:.2f} m/s')\n\n        # Check 4: Robot rotation reasonable\n        angular_vel = math.sqrt(\n            msg.twist[idx].angular.x**2 +\n            msg.twist[idx].angular.y**2 +\n            msg.twist[idx].angular.z**2\n        )\n        if angular_vel > 20.0:  # > 20 rad/s is spinning too fast\n            self.get_logger().warn(f'\u26a0\ufe0f  High rotation: {angular_vel:.2f} rad/s')\n\n    def link_states_callback(self, msg):\n        \"\"\"Monitor link states for contact forces\"\"\"\n        # Could check contact forces here\n        pass\n\n    def report_validation(self):\n        \"\"\"Print validation report\"\"\"\n        self.get_logger().info('=== PHYSICS VALIDATION REPORT ===')\n        if self.falling:\n            self.get_logger().info('\u2705 Gravity: OK')\n        else:\n            self.get_logger().info('\u274c Gravity: NOT DETECTED')\n\n\ndef main(args=None):\n    rclpy.init(args=args)\n    validator = PhysicsValidator()\n\n    # Run for 10 seconds\n    rclpy.spin_once(validator)\n    for _ in range(10):\n        rclpy.spin_once(validator)\n        validator.get_logger().info('...')\n\n    validator.report_validation()\n    validator.destroy_node()\n    rclpy.shutdown()\n\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"hands-on-exercise",children:"Hands-On Exercise"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Task"}),": Create an SDF world with a physics-configured robot and validate behavior."]}),"\n",(0,t.jsx)(e.h3,{id:"step-1-create-physics-test-world",children:"Step 1: Create Physics Test World"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-bash",children:"# Copy SDF file\nmkdir -p ~/gazebo_ws/src/worlds\ncat > ~/gazebo_ws/src/worlds/simple_robot_physics.sdf << 'EOF'\n# (Paste the complete SDF from Part 3 above)\nEOF\n"})}),"\n",(0,t.jsx)(e.h3,{id:"step-2-launch-with-physics-validation",children:"Step 2: Launch with Physics Validation"}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-bash",children:"# Terminal 1: Launch Gazebo\nros2 launch gazebo_ros gazebo.launch.py world:=$HOME/gazebo_ws/src/worlds/simple_robot_physics.sdf\n\n# Terminal 2: Run physics validator\npython3 ~/gazebo_ws/src/physics_validator.py\n"})}),"\n",(0,t.jsx)(e.h3,{id:"step-3-experiments",children:"Step 3: Experiments"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Gravity Test"}),": Verify robot falls from spawn height"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Friction Test"}),": Observe ground contact friction"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Damping Test"}),": Change damping from 0 to 1.0 and observe motion"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Timestep Test"}),": Reduce max_step_size to 0.0001 and check stability"]}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"exercises",children:"Exercises"}),"\n",(0,t.jsxs)(e.ol,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"High Damping"}),": Set damping to 1.0 and observe sluggish motion"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"No Friction"}),": Set ground friction to 0.0 and observe sliding"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"High ERP"}),": Set ERP to 0.5 and observe constraint stiffness"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Small Timestep"}),": Use max_step_size 0.0001 for maximum accuracy"]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.strong,{children:"Real-time Factor"}),": Set to 2.0 and watch simulation run 2x faster"]}),"\n"]}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"common-physics-issues--solutions",children:"Common Physics Issues & Solutions"}),"\n",(0,t.jsxs)(e.table,{children:[(0,t.jsx)(e.thead,{children:(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.th,{children:"Issue"}),(0,t.jsx)(e.th,{children:"Cause"}),(0,t.jsx)(e.th,{children:"Solution"})]})}),(0,t.jsxs)(e.tbody,{children:[(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:"Robot falls through ground"}),(0,t.jsx)(e.td,{children:"No collision or bad inertia"}),(0,t.jsx)(e.td,{children:"Add collision geometry, check inertia values"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:"Robot oscillates/shakes"}),(0,t.jsx)(e.td,{children:"ERP too high, small timestep"}),(0,t.jsx)(e.td,{children:"Reduce ERP to 0.2, increase timestep to 0.001"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:"Joints move too fast"}),(0,t.jsx)(e.td,{children:"Low damping, low effort limit"}),(0,t.jsx)(e.td,{children:"Increase damping to 0.3, reduce velocity limit"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:"Robot doesn't move"}),(0,t.jsx)(e.td,{children:"High friction/damping"}),(0,t.jsx)(e.td,{children:"Reduce both to 0.1, check joint effort"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:"Simulation very slow"}),(0,t.jsx)(e.td,{children:"Timestep too small"}),(0,t.jsx)(e.td,{children:"Increase from 0.0001 to 0.001"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:"Contacts not working"}),(0,t.jsx)(e.td,{children:"CFM/ERP bad values"}),(0,t.jsx)(e.td,{children:"Use defaults: cfm=0.0, erp=0.2"})]}),(0,t.jsxs)(e.tr,{children:[(0,t.jsx)(e.td,{children:"Joint limits not enforced"}),(0,t.jsx)(e.td,{children:"Missing limit element in SDF"}),(0,t.jsxs)(e.td,{children:["Add ",(0,t.jsx)(e.code,{children:"<limit>"})," with lower/upper/effort"]})]})]})]}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,t.jsxs)(e.p,{children:["\u2705 ",(0,t.jsx)(e.strong,{children:"URDF Limitations"}),": Designed for visualization, missing simulation physics details"]}),"\n",(0,t.jsxs)(e.p,{children:["\u2705 ",(0,t.jsx)(e.strong,{children:"SDF Advantages"}),": Purpose-built for physics simulation with full parameter control"]}),"\n",(0,t.jsxs)(e.p,{children:["\u2705 ",(0,t.jsx)(e.strong,{children:"Conversion Process"}),": Automatic tools exist, but manual tuning needed for accuracy"]}),"\n",(0,t.jsxs)(e.p,{children:["\u2705 ",(0,t.jsx)(e.strong,{children:"Physics Parameters"}),": Damping, friction, ERP, CFM control simulation behavior"]}),"\n",(0,t.jsxs)(e.p,{children:["\u2705 ",(0,t.jsx)(e.strong,{children:"Tuning Strategy"}),": Start with defaults, adjust iteratively based on validation"]}),"\n",(0,t.jsxs)(e.p,{children:["\u2705 ",(0,t.jsx)(e.strong,{children:"Trade-offs"}),": Accuracy vs. speed\u2014smaller timestep = more accurate but slower"]}),"\n",(0,t.jsxs)(e.p,{children:["\u2705 ",(0,t.jsx)(e.strong,{children:"Validation"}),": Always test gravity, collisions, and motion before deployment"]}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsx)(e.h2,{id:"further-reading",children:"Further Reading"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:["\ud83d\udcd6 ",(0,t.jsx)(e.a,{href:"http://sdformat.org/",children:"Gazebo SDF Specification"})]}),"\n",(0,t.jsxs)(e.li,{children:["\ud83d\udcd6 ",(0,t.jsx)(e.a,{href:"http://www.ode.org/wiki/index.php/Manual",children:"ODE Physics Tuning Guide"})]}),"\n",(0,t.jsxs)(e.li,{children:["\ud83d\udcd6 ",(0,t.jsx)(e.a,{href:"https://classic.gazebosim.org/tutorials?tut=ros2_urdf&cat=ign&ver=igni",children:"URDF to SDF Conversion"})]}),"\n",(0,t.jsxs)(e.li,{children:["\ud83d\udcd6 ",(0,t.jsx)(e.a,{href:"https://gazebosim.org/docs",children:"Humanoid Physics in Gazebo"})]}),"\n"]}),"\n",(0,t.jsx)(e.hr,{}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Next Lesson"}),": ",(0,t.jsx)(e.a,{href:"/physical-ai-textbook/docs/chapter-2/2-3-sensors-unity",children:"Lesson 2.3: Sensor Simulation & Unity Integration"})]}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.strong,{children:"Questions?"})," See ",(0,t.jsx)(e.a,{href:"/physical-ai-textbook/docs/faq",children:"FAQ"})," or ",(0,t.jsx)(e.a,{href:"https://github.com/physical-ai-course/physical-ai-textbook/discussions",children:"GitHub Discussions"})]})]})}function h(n={}){const{wrapper:e}={...(0,r.R)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(d,{...n})}):d(n)}},8453:function(n,e,i){i.d(e,{R:function(){return o},x:function(){return l}});var s=i(6540);const t={},r=s.createContext(t);function o(n){const e=s.useContext(r);return s.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function l(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(t):n.components||t:o(n.components),s.createElement(r.Provider,{value:e},n.children)}}}]);