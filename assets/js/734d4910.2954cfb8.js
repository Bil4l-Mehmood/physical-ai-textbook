"use strict";(self.webpackChunkphysical_ai_textbook=self.webpackChunkphysical_ai_textbook||[]).push([[531],{5587:function(n,r,e){e.r(r),e.d(r,{assets:function(){return a},contentTitle:function(){return l},default:function(){return h},frontMatter:function(){return o},metadata:function(){return i},toc:function(){return c}});var i=JSON.parse('{"id":"chapter-2/2-2-urdf-sdf-physics","title":"Converting URDF to SDF and Configuring Physics","description":"Master URDF-to-SDF conversion and tune physics parameters for realistic robot simulation","source":"@site/docs/chapter-2/2-2-urdf-sdf-physics.md","sourceDirName":"chapter-2","slug":"/chapter-2/2-2-urdf-sdf-physics","permalink":"/physical-ai-textbook/docs/chapter-2/2-2-urdf-sdf-physics","draft":false,"unlisted":false,"editUrl":"https://github.com/Bil4l-Mehmood/physical-ai-textbook/edit/main/docs/chapter-2/2-2-urdf-sdf-physics.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2,"sidebar_label":"Lesson 2.2: URDF/SDF & Physics","title":"Converting URDF to SDF and Configuring Physics","description":"Master URDF-to-SDF conversion and tune physics parameters for realistic robot simulation","duration":90,"difficulty":"Intermediate","hardware":["Ubuntu 22.04 LTS","ROS 2 Humble","Gazebo Harmonic"],"prerequisites":["Lesson 1.4: URDF/XACRO Basics","Lesson 2.1: Gazebo Fundamentals"]},"sidebar":"tutorialSidebar","previous":{"title":"Lesson 2.1: Gazebo Fundamentals","permalink":"/physical-ai-textbook/docs/chapter-2/2-1-gazebo-fundamentals"},"next":{"title":"Lesson 2.3: Sensors & Unity","permalink":"/physical-ai-textbook/docs/chapter-2/2-3-sensors-unity"}}'),s=e(4848),t=e(8453);const o={sidebar_position:2,sidebar_label:"Lesson 2.2: URDF/SDF & Physics",title:"Converting URDF to SDF and Configuring Physics",description:"Master URDF-to-SDF conversion and tune physics parameters for realistic robot simulation",duration:90,difficulty:"Intermediate",hardware:["Ubuntu 22.04 LTS","ROS 2 Humble","Gazebo Harmonic"],prerequisites:["Lesson 1.4: URDF/XACRO Basics","Lesson 2.1: Gazebo Fundamentals"]},l="Lesson 2.2: URDF/SDF & Physics Configuration",a={},c=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Part 1: URDF vs SDF for Simulation",id:"part-1-urdf-vs-sdf-for-simulation",level:2},{value:"Key Differences",id:"key-differences",level:3},{value:"URDF to SDF Conversion Process",id:"urdf-to-sdf-conversion-process",level:3},{value:"Part 2: Automatic URDF to SDF Conversion",id:"part-2-automatic-urdf-to-sdf-conversion",level:2},{value:"Method 1: Using <code>urdf_to_sdf</code> Tool",id:"method-1-using-urdf_to_sdf-tool",level:3},{value:"Method 2: Using Python Script",id:"method-2-using-python-script",level:3},{value:"Part 3: Enhanced SDF with Physics Parameters",id:"part-3-enhanced-sdf-with-physics-parameters",level:2},{value:"Complete Robot SDF with Physics Tuning",id:"complete-robot-sdf-with-physics-tuning",level:3},{value:"Part 4: Physics Parameter Tuning Guide",id:"part-4-physics-parameter-tuning-guide",level:2},{value:"Understanding Key Parameters",id:"understanding-key-parameters",level:3},{value:"Tuning Strategy for Different Robots",id:"tuning-strategy-for-different-robots",level:3},{value:"Part 5: Testing and Validation",id:"part-5-testing-and-validation",level:2},{value:"Simulation Validation Script",id:"simulation-validation-script",level:3},{value:"Hands-On Exercise",id:"hands-on-exercise",level:2},{value:"Step 1: Create Physics Test World",id:"step-1-create-physics-test-world",level:3},{value:"Step 2: Launch with Physics Validation",id:"step-2-launch-with-physics-validation",level:3},{value:"Step 3: Experiments",id:"step-3-experiments",level:3},{value:"Exercises",id:"exercises",level:3},{value:"Common Physics Issues &amp; Solutions",id:"common-physics-issues--solutions",level:2},{value:"Key Takeaways",id:"key-takeaways",level:2},{value:"Further Reading",id:"further-reading",level:2}];function d(n){const r={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...n.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(r.header,{children:(0,s.jsx)(r.h1,{id:"lesson-22-urdfsdf--physics-configuration",children:"Lesson 2.2: URDF/SDF & Physics Configuration"})}),"\n",(0,s.jsxs)(r.admonition,{title:"Lesson Overview",type:"info",children:[(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"Duration"}),": 90 minutes | ",(0,s.jsx)(r.strong,{children:"Difficulty"}),": Intermediate | ",(0,s.jsx)(r.strong,{children:"Hardware"}),": Ubuntu 22.04 + ROS 2 Humble + Gazebo"]}),(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"Prerequisites"}),": Lessons 1.4 and 2.1"]}),(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"Learning Outcome"}),": Convert URDF to SDF and configure realistic physics for simulation"]})]}),"\n",(0,s.jsx)(r.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,s.jsx)(r.p,{children:"By the end of this lesson, you will be able to:"}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsx)(r.li,{children:"Understand URDF limitations for simulation"}),"\n",(0,s.jsx)(r.li,{children:"Convert URDF files to SDF format using tools"}),"\n",(0,s.jsx)(r.li,{children:"Add simulation-specific parameters to models"}),"\n",(0,s.jsx)(r.li,{children:"Configure inertia properties for accurate physics"}),"\n",(0,s.jsx)(r.li,{children:"Tune friction, damping, and contact parameters"}),"\n",(0,s.jsx)(r.li,{children:"Test and validate physics configurations"}),"\n",(0,s.jsx)(r.li,{children:"Optimize simulation stability and realism"}),"\n",(0,s.jsx)(r.li,{children:"Debug physics errors and instabilities"}),"\n"]}),"\n",(0,s.jsx)(r.h2,{id:"part-1-urdf-vs-sdf-for-simulation",children:"Part 1: URDF vs SDF for Simulation"}),"\n",(0,s.jsx)(r.h3,{id:"key-differences",children:"Key Differences"}),"\n",(0,s.jsxs)(r.table,{children:[(0,s.jsx)(r.thead,{children:(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.th,{children:"Feature"}),(0,s.jsx)(r.th,{children:"URDF"}),(0,s.jsx)(r.th,{children:"SDF"})]})}),(0,s.jsxs)(r.tbody,{children:[(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.strong,{children:"Purpose"})}),(0,s.jsx)(r.td,{children:"Visualization + ROS 2 communication"}),(0,s.jsx)(r.td,{children:"Physics simulation"})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.strong,{children:"Inertia Requirement"})}),(0,s.jsx)(r.td,{children:"Optional"}),(0,s.jsxs)(r.td,{children:[(0,s.jsx)(r.strong,{children:"Required"})," for accurate physics"]})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.strong,{children:"Friction"})}),(0,s.jsx)(r.td,{children:"Basic (single value)"}),(0,s.jsx)(r.td,{children:"Advanced (separate directions)"})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.strong,{children:"Damping"})}),(0,s.jsx)(r.td,{children:"Not specified"}),(0,s.jsx)(r.td,{children:"Full support (linear + angular)"})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.strong,{children:"Sensors"})}),(0,s.jsx)(r.td,{children:"Basic declaration"}),(0,s.jsx)(r.td,{children:"Full plugin integration"})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.strong,{children:"Collision Mesh"})}),(0,s.jsx)(r.td,{children:"Simple geometries"}),(0,s.jsx)(r.td,{children:"Complex meshes supported"})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.strong,{children:"Physics Engine"})}),(0,s.jsx)(r.td,{children:"Not specified"}),(0,s.jsx)(r.td,{children:"Engine-specific options"})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:(0,s.jsx)(r.strong,{children:"Extensibility"})}),(0,s.jsx)(r.td,{children:"Limited"}),(0,s.jsx)(r.td,{children:"Plugins for custom behavior"})]})]})]}),"\n",(0,s.jsx)(r.h3,{id:"urdf-to-sdf-conversion-process",children:"URDF to SDF Conversion Process"}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"URDF (From Lesson 1.4)"}),":"]}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:["Defines ",(0,s.jsx)(r.strong,{children:"structure"})," (links & joints)"]}),"\n",(0,s.jsxs)(r.li,{children:["Specifies ",(0,s.jsx)(r.strong,{children:"inertia"})," (mass, moment of inertia)"]}),"\n",(0,s.jsxs)(r.li,{children:["Describes ",(0,s.jsx)(r.strong,{children:"appearance"})," (visual geometry)"]}),"\n"]}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"SDF (For Gazebo)"}),":"]}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:["Adds ",(0,s.jsx)(r.strong,{children:"physics parameters"})," (friction, damping, contact)"]}),"\n",(0,s.jsxs)(r.li,{children:["Specifies ",(0,s.jsx)(r.strong,{children:"simulation properties"})," (solver settings)"]}),"\n",(0,s.jsxs)(r.li,{children:["Includes ",(0,s.jsx)(r.strong,{children:"sensor plugins"})," (camera, lidar, IMU)"]}),"\n",(0,s.jsxs)(r.li,{children:["Defines ",(0,s.jsx)(r.strong,{children:"actuator constraints"})," (effort, velocity limits)"]}),"\n"]}),"\n",(0,s.jsx)(r.hr,{}),"\n",(0,s.jsx)(r.h2,{id:"part-2-automatic-urdf-to-sdf-conversion",children:"Part 2: Automatic URDF to SDF Conversion"}),"\n",(0,s.jsxs)(r.h3,{id:"method-1-using-urdf_to_sdf-tool",children:["Method 1: Using ",(0,s.jsx)(r.code,{children:"urdf_to_sdf"})," Tool"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-bash",children:"# Install conversion tool\r\nsudo apt install ros-humble-urdf-to-sdf\r\n\r\n# Convert your URDF\r\nurdf_to_sdf input.urdf -o output.sdf\r\n\r\n# Verify conversion\r\ngazebo output.sdf\n"})}),"\n",(0,s.jsx)(r.h3,{id:"method-2-using-python-script",children:"Method 2: Using Python Script"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-python",children:"#!/usr/bin/env python3\r\n\"\"\"\r\nConvert URDF to SDF with custom physics parameters\r\n\"\"\"\r\n\r\nfrom urdf_parser_py.urdf import URDF\r\nimport xml.etree.ElementTree as ET\r\n\r\n\r\ndef urdf_to_sdf(urdf_file, output_file):\r\n    \"\"\"\r\n    Convert URDF file to SDF format\r\n\r\n    Args:\r\n        urdf_file: Path to input URDF\r\n        output_file: Path to output SDF\r\n    \"\"\"\r\n\r\n    # Parse URDF\r\n    robot = URDF.from_xml_file(urdf_file)\r\n\r\n    # Create SDF root\r\n    sdf_root = ET.Element('sdf', version='1.10')\r\n    world = ET.SubElement(sdf_root, 'world', name='converted_world')\r\n\r\n    # Add physics\r\n    physics = ET.SubElement(world, 'physics', type='ode')\r\n    ET.SubElement(physics, 'max_step_size').text = '0.001'\r\n    ET.SubElement(physics, 'real_time_factor').text = '1.0'\r\n    ET.SubElement(physics, 'real_time_update_rate').text = '1000'\r\n\r\n    # Add light\r\n    light = ET.SubElement(world, 'light', name='sun', type='directional')\r\n    ET.SubElement(light, 'pose').text = '0 0 10 0 0 0'\r\n    ET.SubElement(light, 'diffuse').text = '0.8 0.8 0.8 1'\r\n\r\n    # Convert robot to SDF model\r\n    model = ET.SubElement(world, 'model', name=robot.name)\r\n    ET.SubElement(model, 'pose').text = '0 0 0 0 0 0'\r\n\r\n    # Convert URDF links to SDF links\r\n    for link in robot.links:\r\n        sdf_link = ET.SubElement(model, 'link', name=link.name)\r\n\r\n        # Add inertial (required for physics)\r\n        if link.inertial:\r\n            inertial = ET.SubElement(sdf_link, 'inertial')\r\n            inertial_pose = ET.SubElement(inertial, 'pose')\r\n            inertial_pose.text = f\"{link.inertial.origin.xyz[0]} {link.inertial.origin.xyz[1]} {link.inertial.origin.xyz[2]} 0 0 0\"\r\n\r\n            mass = ET.SubElement(inertial, 'mass')\r\n            mass.text = str(link.inertial.mass)\r\n\r\n            inertia = ET.SubElement(inertial, 'inertia')\r\n            ET.SubElement(inertia, 'ixx').text = str(link.inertial.inertia.ixx)\r\n            ET.SubElement(inertia, 'iyy').text = str(link.inertial.inertia.iyy)\r\n            ET.SubElement(inertia, 'izz').text = str(link.inertial.inertia.izz)\r\n\r\n        # Add visual (from URDF)\r\n        if link.visual:\r\n            visual = ET.SubElement(sdf_link, 'visual', name='visual')\r\n            visual_pose = ET.SubElement(visual, 'pose')\r\n            visual_pose.text = f\"{link.visual[0].origin.xyz[0]} {link.visual[0].origin.xyz[1]} {link.visual[0].origin.xyz[2]} 0 0 0\"\r\n            # ... add geometry ...\r\n\r\n        # Add collision with friction\r\n        if link.collision:\r\n            collision = ET.SubElement(sdf_link, 'collision', name='collision')\r\n            collision_pose = ET.SubElement(collision, 'pose')\r\n            collision_pose.text = f\"{link.collision[0].origin.xyz[0]} {link.collision[0].origin.xyz[1]} {link.collision[0].origin.xyz[2]} 0 0 0\"\r\n            # ... add geometry and friction ...\r\n\r\n    # Convert joints\r\n    for joint in robot.joints:\r\n        sdf_joint = ET.SubElement(model, 'joint', name=joint.name, type=joint.type)\r\n        ET.SubElement(sdf_joint, 'parent').text = joint.parent.link\r\n        ET.SubElement(sdf_joint, 'child').text = joint.child.link\r\n        ET.SubElement(sdf_joint, 'pose').text = f\"{joint.origin.xyz[0]} {joint.origin.xyz[1]} {joint.origin.xyz[2]} 0 0 0\"\r\n\r\n        # Add axis\r\n        axis = ET.SubElement(sdf_joint, 'axis')\r\n        ET.SubElement(axis, 'xyz').text = f\"{joint.axis[0]} {joint.axis[1]} {joint.axis[2]}\"\r\n\r\n        # Add limits\r\n        limits = ET.SubElement(sdf_joint, 'axis')\r\n        if hasattr(joint, 'limit'):\r\n            ET.SubElement(limits, 'lower').text = str(joint.limit.lower)\r\n            ET.SubElement(limits, 'upper').text = str(joint.limit.upper)\r\n            ET.SubElement(limits, 'effort').text = str(joint.limit.effort)\r\n            ET.SubElement(limits, 'velocity').text = str(joint.limit.velocity)\r\n\r\n    # Write SDF\r\n    tree = ET.ElementTree(sdf_root)\r\n    tree.write(output_file, encoding='utf-8', xml_declaration=True)\r\n\r\n    print(f\"Converted {urdf_file} \u2192 {output_file}\")\r\n\r\n\r\nif __name__ == '__main__':\r\n    urdf_to_sdf('simple_robot.urdf', 'simple_robot.sdf')\n"})}),"\n",(0,s.jsx)(r.hr,{}),"\n",(0,s.jsx)(r.h2,{id:"part-3-enhanced-sdf-with-physics-parameters",children:"Part 3: Enhanced SDF with Physics Parameters"}),"\n",(0,s.jsx)(r.h3,{id:"complete-robot-sdf-with-physics-tuning",children:"Complete Robot SDF with Physics Tuning"}),"\n",(0,s.jsxs)(r.p,{children:["Create ",(0,s.jsx)(r.code,{children:"simple_robot_physics.sdf"}),":"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-xml",children:'<?xml version="1.0" ?>\r\n\x3c!-- Copyright (c) 2025 Physical AI Course\r\n     License: MIT\r\n     Target: Ubuntu 22.04 + ROS 2 Humble + Gazebo\r\n--\x3e\r\n<sdf version="1.10">\r\n  <world name="robot_physics_world">\r\n\r\n    \x3c!-- Physics Engine Configuration --\x3e\r\n    <physics name="physics" type="ode">\r\n      \x3c!-- Simulation timestep: smaller = more accurate but slower --\x3e\r\n      <max_step_size>0.001</max_step_size>\r\n\r\n      \x3c!-- Realtime factor: 1.0 = normal speed, 2.0 = 2x faster --\x3e\r\n      <real_time_factor>1.0</real_time_factor>\r\n\r\n      \x3c!-- Update rate: how often to publish states --\x3e\r\n      <real_time_update_rate>1000</real_time_update_rate>\r\n\r\n      \x3c!-- Gravity (m/s^2): Earth = -9.81 in z direction --\x3e\r\n      <gravity>0 0 -9.81</gravity>\r\n\r\n      \x3c!-- ODE Solver Settings --\x3e\r\n      <ode>\r\n        <solver>\r\n          \x3c!-- \'quick\' is faster but less accurate; \'world\' is more accurate --\x3e\r\n          <type>quick</type>\r\n\r\n          \x3c!-- Number of iterations for solver --\x3e\r\n          <iters>50</iters>\r\n\r\n          \x3c!-- Preconditioning iterations (0 = faster, 1 = more stable) --\x3e\r\n          <precon_iters>0</precon_iters>\r\n\r\n          \x3c!-- Successive Over-Relaxation: 1.3 = default, 1.0 = slower convergence --\x3e\r\n          <sor>1.400000</sor>\r\n        </solver>\r\n\r\n        \x3c!-- Contact and constraint settings --\x3e\r\n        <constraints>\r\n          \x3c!-- Constraint Force Mixing: higher = softer contacts --\x3e\r\n          <cfm>0.000000</cfm>\r\n\r\n          \x3c!-- Error Reduction Parameter: higher = faster stabilization --\x3e\r\n          <erp>0.200000</erp>\r\n\r\n          \x3c!-- Max velocity for contact correction (m/s) --\x3e\r\n          <contact_max_correcting_vel>100.000000</contact_max_correcting_vel>\r\n\r\n          \x3c!-- Contact surface layer depth (m) --\x3e\r\n          <contact_surface_layer>0.001000</contact_surface_layer>\r\n        </constraints>\r\n      </ode>\r\n    </physics>\r\n\r\n    \x3c!-- Lighting --\x3e\r\n    <light name="sun" type="directional">\r\n      <cast_shadows>true</cast_shadows>\r\n      <pose>0 0 10 0 0 0</pose>\r\n      <diffuse>0.8 0.8 0.8 1</diffuse>\r\n      <direction>-0.5 0.1 -0.9</direction>\r\n    </light>\r\n\r\n    \x3c!-- Ground Plane with Friction --\x3e\r\n    <model name="ground_plane">\r\n      <static>true</static>\r\n      <link name="link">\r\n        <collision name="collision">\r\n          <geometry>\r\n            <plane>\r\n              <normal>0 0 1</normal>\r\n              <size>100 100</size>\r\n            </plane>\r\n          </geometry>\r\n          \x3c!-- Ground friction --\x3e\r\n          <surface>\r\n            <friction>\r\n              <ode>\r\n                \x3c!-- Coefficient of friction (0.6 = rubber on concrete) --\x3e\r\n                <mu>0.6</mu>\r\n                \x3c!-- Second friction direction --\x3e\r\n                <mu2>0.6</mu2>\r\n                \x3c!-- Slip velocity threshold --\x3e\r\n                <slip1>0.001</slip1>\r\n                <slip2>0.001</slip2>\r\n              </ode>\r\n            </friction>\r\n            <contact>\r\n              \x3c!-- Soft contact parameters for stability --\x3e\r\n              <ode>\r\n                <soft_cfm>0.0</soft_cfm>\r\n                <soft_erp>0.2</soft_erp>\r\n              </ode>\r\n            </contact>\r\n          </surface>\r\n        </collision>\r\n        <visual name="visual">\r\n          <geometry>\r\n            <plane>\r\n              <normal>0 0 1</normal>\r\n              <size>100 100</size>\r\n            </plane>\r\n          </geometry>\r\n          <material>\r\n            <ambient>0.8 0.8 0.8 1</ambient>\r\n            <diffuse>0.8 0.8 0.8 1</diffuse>\r\n          </material>\r\n        </visual>\r\n      </link>\r\n    </model>\r\n\r\n    \x3c!-- Robot Model --\x3e\r\n    <model name="simple_robot_physics">\r\n      <pose>0 0 0.5 0 0 0</pose>\r\n\r\n      \x3c!-- Base Link --\x3e\r\n      <link name="base_link">\r\n        <inertial>\r\n          <mass>1.0</mass>\r\n          <inertia>\r\n            <ixx>0.01</ixx>\r\n            <iyy>0.01</iyy>\r\n            <izz>0.01</izz>\r\n          </inertia>\r\n        </inertial>\r\n        <visual name="visual">\r\n          <geometry>\r\n            <box>\r\n              <size>0.1 0.1 0.1</size>\r\n            </box>\r\n          </geometry>\r\n          <material>\r\n            <ambient>0.5 0.5 0.5 1</ambient>\r\n            <diffuse>0.5 0.5 0.5 1</diffuse>\r\n          </material>\r\n        </visual>\r\n        <collision name="collision">\r\n          <geometry>\r\n            <box>\r\n              <size>0.1 0.1 0.1</size>\r\n            </box>\r\n          </geometry>\r\n          <surface>\r\n            <friction>\r\n              <ode>\r\n                <mu>0.4</mu>\r\n                <mu2>0.4</mu2>\r\n              </ode>\r\n            </friction>\r\n          </surface>\r\n        </collision>\r\n      </link>\r\n\r\n      \x3c!-- Joint 1 with Dynamics --\x3e\r\n      <joint name="joint_1" type="revolute">\r\n        <parent>base_link</parent>\r\n        <child>link_1</child>\r\n        <pose>0 0 0.1 0 0 0</pose>\r\n        <axis>\r\n          <xyz>0 1 0</xyz>\r\n          \x3c!-- Joint damping: resists motion (b in F = -b*v) --\x3e\r\n          <dynamics>\r\n            <damping>0.1</damping>\r\n            \x3c!-- Friction: constant resistance to motion --\x3e\r\n            <friction>0.0</friction>\r\n          </dynamics>\r\n        </axis>\r\n        \x3c!-- Joint limits --\x3e\r\n        <limit>\r\n          <lower>-1.5708</lower>\r\n          <upper>1.5708</upper>\r\n          <effort>10</effort>\r\n          <velocity>1</velocity>\r\n        </limit>\r\n      </joint>\r\n\r\n      \x3c!-- Link 1 --\x3e\r\n      <link name="link_1">\r\n        <inertial>\r\n          <mass>0.5</mass>\r\n          <origin xyz="0 0 0.05"/>\r\n          <inertia>\r\n            <ixx>0.005</ixx>\r\n            <iyy>0.005</iyy>\r\n            <izz>0.001</izz>\r\n          </inertia>\r\n        </inertial>\r\n        <visual name="visual">\r\n          <origin xyz="0 0 0.05"/>\r\n          <geometry>\r\n            <cylinder>\r\n              <radius>0.02</radius>\r\n              <length>0.1</length>\r\n            </cylinder>\r\n          </geometry>\r\n          <material>\r\n            <ambient>0.2 0.2 0.8 1</ambient>\r\n            <diffuse>0.2 0.2 0.8 1</diffuse>\r\n          </material>\r\n        </visual>\r\n        <collision name="collision">\r\n          <origin xyz="0 0 0.05"/>\r\n          <geometry>\r\n            <cylinder>\r\n              <radius>0.02</radius>\r\n              <length>0.1</length>\r\n            </cylinder>\r\n          </geometry>\r\n          <surface>\r\n            <friction>\r\n              <ode>\r\n                <mu>0.4</mu>\r\n                <mu2>0.4</mu2>\r\n              </ode>\r\n            </friction>\r\n          </surface>\r\n        </collision>\r\n      </link>\r\n\r\n      \x3c!-- Joint 2 --\x3e\r\n      <joint name="joint_2" type="revolute">\r\n        <parent>link_1</parent>\r\n        <child>link_2</child>\r\n        <pose>0 0 0.1 0 0 0</pose>\r\n        <axis>\r\n          <xyz>0 1 0</xyz>\r\n          <dynamics>\r\n            <damping>0.1</damping>\r\n            <friction>0.0</friction>\r\n          </dynamics>\r\n        </axis>\r\n        <limit>\r\n          <lower>-1.5708</lower>\r\n          <upper>1.5708</upper>\r\n          <effort>10</effort>\r\n          <velocity>1</velocity>\r\n        </limit>\r\n      </joint>\r\n\r\n      \x3c!-- Link 2 (End Effector) --\x3e\r\n      <link name="link_2">\r\n        <inertial>\r\n          <mass>0.3</mass>\r\n          <origin xyz="0 0 0.05"/>\r\n          <inertia>\r\n            <ixx>0.003</ixx>\r\n            <iyy>0.003</iyy>\r\n            <izz>0.0005</izz>\r\n          </inertia>\r\n        </inertial>\r\n        <visual name="visual">\r\n          <origin xyz="0 0 0.05"/>\r\n          <geometry>\r\n            <cylinder>\r\n              <radius>0.015</radius>\r\n              <length>0.1</length>\r\n            </cylinder>\r\n          </geometry>\r\n          <material>\r\n            <ambient>0.8 0.2 0.2 1</ambient>\r\n            <diffuse>0.8 0.2 0.2 1</diffuse>\r\n          </material>\r\n        </visual>\r\n        <collision name="collision">\r\n          <origin xyz="0 0 0.05"/>\r\n          <geometry>\r\n            <cylinder>\r\n              <radius>0.015</radius>\r\n              <length>0.1</length>\r\n            </cylinder>\r\n          </geometry>\r\n          <surface>\r\n            <friction>\r\n              <ode>\r\n                <mu>0.4</mu>\r\n                <mu2>0.4</mu2>\r\n              </ode>\r\n            </friction>\r\n          </surface>\r\n        </collision>\r\n      </link>\r\n\r\n    </model>\r\n\r\n  </world>\r\n</sdf>\n'})}),"\n",(0,s.jsx)(r.hr,{}),"\n",(0,s.jsx)(r.h2,{id:"part-4-physics-parameter-tuning-guide",children:"Part 4: Physics Parameter Tuning Guide"}),"\n",(0,s.jsx)(r.h3,{id:"understanding-key-parameters",children:"Understanding Key Parameters"}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"Damping"})," (Linear & Angular):"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{children:"Force = -damping * velocity\r\nEffect: Dissipates energy over time (like air resistance)\r\nRange: 0.0 (no damping) to 1.0+ (heavy damping)\r\nRobot arm: 0.1 (light damping for smooth motion)\r\nHumanoid: 0.5+ (heavier damping for stability)\n"})}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"Friction Coefficient (\u03bc)"}),":"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{children:"Friction = \u03bc * Normal_Force\r\nEffect: Prevents sliding on surfaces\r\nCommon values:\r\n  - 0.1: Ice/slippery surface\r\n  - 0.4: Plastic on concrete\r\n  - 0.6: Rubber on concrete\r\n  - 1.0+: High-grip materials\n"})}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"Error Reduction Parameter (ERP)"}),":"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{children:"ERP = Fraction of error corrected per timestep\r\nEffect: How aggressively constraints are enforced\r\nRange: 0.0 (no correction) to 1.0 (full correction)\r\nValue: 0.2 (default, good balance)\r\nLower: More accurate but slower convergence\r\nHigher: Faster but may oscillate\n"})}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"Constraint Force Mixing (CFM)"}),":"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{children:"CFM = Softness of constraints\r\nEffect: Allows slight constraint violations for stability\r\nRange: 0.0 (very stiff) to 0.1 (soft)\r\nValue: 0.0 (default, rigid constraints)\r\nHigher CFM: More flexible, slower convergence\n"})}),"\n",(0,s.jsx)(r.h3,{id:"tuning-strategy-for-different-robots",children:"Tuning Strategy for Different Robots"}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"Stable Robot (Low velocity, robust)"}),":"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-xml",children:"<damping>0.5</damping>        \x3c!-- Higher damping --\x3e\r\n<friction>0.8</friction>       \x3c!-- High friction --\x3e\r\n<erp>0.2</erp>                 \x3c!-- Standard ERP --\x3e\r\n<cfm>0.0</cfm>                 \x3c!-- Rigid constraints --\x3e\r\n<max_step_size>0.001</max_step_size>\n"})}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"Fast Robot (High velocity, agile)"}),":"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-xml",children:"<damping>0.1</damping>         \x3c!-- Low damping --\x3e\r\n<friction>0.4</friction>       \x3c!-- Lower friction --\x3e\r\n<erp>0.5</erp>                 \x3c!-- Higher ERP for stability --\x3e\r\n<cfm>0.0</cfm>                 \x3c!-- Rigid --\x3e\r\n<max_step_size>0.0005</max_step_size>  \x3c!-- Smaller timestep --\x3e\n"})}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"Humanoid Robot (Balanced, realistic)"}),":"]}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-xml",children:"<damping>0.3</damping>         \x3c!-- Moderate damping --\x3e\r\n<friction>0.6</friction>       \x3c!-- Standard friction --\x3e\r\n<erp>0.2</erp>                 \x3c!-- Standard ERP --\x3e\r\n<cfm>0.0</cfm>                 \x3c!-- Rigid --\x3e\r\n<max_step_size>0.001</max_step_size>\n"})}),"\n",(0,s.jsx)(r.hr,{}),"\n",(0,s.jsx)(r.h2,{id:"part-5-testing-and-validation",children:"Part 5: Testing and Validation"}),"\n",(0,s.jsx)(r.h3,{id:"simulation-validation-script",children:"Simulation Validation Script"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-python",children:"#!/usr/bin/env python3\r\n\"\"\"\r\nValidate physics simulation of robot\r\nCheck for common physics issues\r\n\"\"\"\r\n\r\nimport rclpy\r\nfrom rclpy.node import Node\r\nfrom gazebo_msgs.msg import ModelState, LinkState\r\nfrom geometry_msgs.msg import Twist\r\nimport math\r\n\r\n\r\nclass PhysicsValidator(Node):\r\n    \"\"\"Validate robot physics in Gazebo\"\"\"\r\n\r\n    def __init__(self):\r\n        super().__init__('physics_validator')\r\n\r\n        # Subscribers\r\n        self.model_states_sub = self.create_subscription(\r\n            ModelState,\r\n            '/gazebo/model_states',\r\n            self.model_states_callback,\r\n            10\r\n        )\r\n\r\n        self.link_states_sub = self.create_subscription(\r\n            LinkState,\r\n            '/gazebo/link_states',\r\n            self.link_states_callback,\r\n            10\r\n        )\r\n\r\n        self.initial_height = None\r\n        self.falling = False\r\n        self.get_logger().info('Physics validator initialized')\r\n\r\n    def model_states_callback(self, msg):\r\n        \"\"\"Monitor model states for physics validation\"\"\"\r\n        if 'simple_robot' not in msg.name:\r\n            return\r\n\r\n        idx = msg.name.index('simple_robot')\r\n        pose = msg.pose[idx]\r\n\r\n        # Check 1: Robot falls due to gravity\r\n        if self.initial_height is None:\r\n            self.initial_height = pose.position.z\r\n            self.get_logger().info(f'Initial height: {self.initial_height:.3f}m')\r\n\r\n        # Robot should fall in first seconds\r\n        if pose.position.z < self.initial_height - 0.3:\r\n            if not self.falling:\r\n                self.falling = True\r\n                self.get_logger().info('\u2705 Gravity working: Robot is falling')\r\n\r\n        # Check 2: Robot doesn't fall through ground (z > 0)\r\n        if pose.position.z < 0:\r\n            self.get_logger().error('\u274c PHYSICS ERROR: Robot penetrated ground!')\r\n\r\n        # Check 3: Robot velocity reasonable\r\n        vel_magnitude = math.sqrt(\r\n            msg.twist[idx].linear.x**2 +\r\n            msg.twist[idx].linear.y**2 +\r\n            msg.twist[idx].linear.z**2\r\n        )\r\n        if vel_magnitude > 10.0:  # > 10 m/s is too fast\r\n            self.get_logger().warn(f'\u26a0\ufe0f  High velocity: {vel_magnitude:.2f} m/s')\r\n\r\n        # Check 4: Robot rotation reasonable\r\n        angular_vel = math.sqrt(\r\n            msg.twist[idx].angular.x**2 +\r\n            msg.twist[idx].angular.y**2 +\r\n            msg.twist[idx].angular.z**2\r\n        )\r\n        if angular_vel > 20.0:  # > 20 rad/s is spinning too fast\r\n            self.get_logger().warn(f'\u26a0\ufe0f  High rotation: {angular_vel:.2f} rad/s')\r\n\r\n    def link_states_callback(self, msg):\r\n        \"\"\"Monitor link states for contact forces\"\"\"\r\n        # Could check contact forces here\r\n        pass\r\n\r\n    def report_validation(self):\r\n        \"\"\"Print validation report\"\"\"\r\n        self.get_logger().info('=== PHYSICS VALIDATION REPORT ===')\r\n        if self.falling:\r\n            self.get_logger().info('\u2705 Gravity: OK')\r\n        else:\r\n            self.get_logger().info('\u274c Gravity: NOT DETECTED')\r\n\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    validator = PhysicsValidator()\r\n\r\n    # Run for 10 seconds\r\n    rclpy.spin_once(validator)\r\n    for _ in range(10):\r\n        rclpy.spin_once(validator)\r\n        validator.get_logger().info('...')\r\n\r\n    validator.report_validation()\r\n    validator.destroy_node()\r\n    rclpy.shutdown()\r\n\r\n\r\nif __name__ == '__main__':\r\n    main()\n"})}),"\n",(0,s.jsx)(r.hr,{}),"\n",(0,s.jsx)(r.h2,{id:"hands-on-exercise",children:"Hands-On Exercise"}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"Task"}),": Create an SDF world with a physics-configured robot and validate behavior."]}),"\n",(0,s.jsx)(r.h3,{id:"step-1-create-physics-test-world",children:"Step 1: Create Physics Test World"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-bash",children:"# Copy SDF file\r\nmkdir -p ~/gazebo_ws/src/worlds\r\ncat > ~/gazebo_ws/src/worlds/simple_robot_physics.sdf << 'EOF'\r\n# (Paste the complete SDF from Part 3 above)\r\nEOF\n"})}),"\n",(0,s.jsx)(r.h3,{id:"step-2-launch-with-physics-validation",children:"Step 2: Launch with Physics Validation"}),"\n",(0,s.jsx)(r.pre,{children:(0,s.jsx)(r.code,{className:"language-bash",children:"# Terminal 1: Launch Gazebo\r\nros2 launch gazebo_ros gazebo.launch.py world:=$HOME/gazebo_ws/src/worlds/simple_robot_physics.sdf\r\n\r\n# Terminal 2: Run physics validator\r\npython3 ~/gazebo_ws/src/physics_validator.py\n"})}),"\n",(0,s.jsx)(r.h3,{id:"step-3-experiments",children:"Step 3: Experiments"}),"\n",(0,s.jsxs)(r.ol,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Gravity Test"}),": Verify robot falls from spawn height"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Friction Test"}),": Observe ground contact friction"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Damping Test"}),": Change damping from 0 to 1.0 and observe motion"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Timestep Test"}),": Reduce max_step_size to 0.0001 and check stability"]}),"\n"]}),"\n",(0,s.jsx)(r.h3,{id:"exercises",children:"Exercises"}),"\n",(0,s.jsxs)(r.ol,{children:["\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"High Damping"}),": Set damping to 1.0 and observe sluggish motion"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"No Friction"}),": Set ground friction to 0.0 and observe sliding"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"High ERP"}),": Set ERP to 0.5 and observe constraint stiffness"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Small Timestep"}),": Use max_step_size 0.0001 for maximum accuracy"]}),"\n",(0,s.jsxs)(r.li,{children:[(0,s.jsx)(r.strong,{children:"Real-time Factor"}),": Set to 2.0 and watch simulation run 2x faster"]}),"\n"]}),"\n",(0,s.jsx)(r.hr,{}),"\n",(0,s.jsx)(r.h2,{id:"common-physics-issues--solutions",children:"Common Physics Issues & Solutions"}),"\n",(0,s.jsxs)(r.table,{children:[(0,s.jsx)(r.thead,{children:(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.th,{children:"Issue"}),(0,s.jsx)(r.th,{children:"Cause"}),(0,s.jsx)(r.th,{children:"Solution"})]})}),(0,s.jsxs)(r.tbody,{children:[(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:"Robot falls through ground"}),(0,s.jsx)(r.td,{children:"No collision or bad inertia"}),(0,s.jsx)(r.td,{children:"Add collision geometry, check inertia values"})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:"Robot oscillates/shakes"}),(0,s.jsx)(r.td,{children:"ERP too high, small timestep"}),(0,s.jsx)(r.td,{children:"Reduce ERP to 0.2, increase timestep to 0.001"})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:"Joints move too fast"}),(0,s.jsx)(r.td,{children:"Low damping, low effort limit"}),(0,s.jsx)(r.td,{children:"Increase damping to 0.3, reduce velocity limit"})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:"Robot doesn't move"}),(0,s.jsx)(r.td,{children:"High friction/damping"}),(0,s.jsx)(r.td,{children:"Reduce both to 0.1, check joint effort"})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:"Simulation very slow"}),(0,s.jsx)(r.td,{children:"Timestep too small"}),(0,s.jsx)(r.td,{children:"Increase from 0.0001 to 0.001"})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:"Contacts not working"}),(0,s.jsx)(r.td,{children:"CFM/ERP bad values"}),(0,s.jsx)(r.td,{children:"Use defaults: cfm=0.0, erp=0.2"})]}),(0,s.jsxs)(r.tr,{children:[(0,s.jsx)(r.td,{children:"Joint limits not enforced"}),(0,s.jsx)(r.td,{children:"Missing limit element in SDF"}),(0,s.jsxs)(r.td,{children:["Add ",(0,s.jsx)(r.code,{children:"<limit>"})," with lower/upper/effort"]})]})]})]}),"\n",(0,s.jsx)(r.hr,{}),"\n",(0,s.jsx)(r.h2,{id:"key-takeaways",children:"Key Takeaways"}),"\n",(0,s.jsxs)(r.p,{children:["\u2705 ",(0,s.jsx)(r.strong,{children:"URDF Limitations"}),": Designed for visualization, missing simulation physics details"]}),"\n",(0,s.jsxs)(r.p,{children:["\u2705 ",(0,s.jsx)(r.strong,{children:"SDF Advantages"}),": Purpose-built for physics simulation with full parameter control"]}),"\n",(0,s.jsxs)(r.p,{children:["\u2705 ",(0,s.jsx)(r.strong,{children:"Conversion Process"}),": Automatic tools exist, but manual tuning needed for accuracy"]}),"\n",(0,s.jsxs)(r.p,{children:["\u2705 ",(0,s.jsx)(r.strong,{children:"Physics Parameters"}),": Damping, friction, ERP, CFM control simulation behavior"]}),"\n",(0,s.jsxs)(r.p,{children:["\u2705 ",(0,s.jsx)(r.strong,{children:"Tuning Strategy"}),": Start with defaults, adjust iteratively based on validation"]}),"\n",(0,s.jsxs)(r.p,{children:["\u2705 ",(0,s.jsx)(r.strong,{children:"Trade-offs"}),": Accuracy vs. speed\u2014smaller timestep = more accurate but slower"]}),"\n",(0,s.jsxs)(r.p,{children:["\u2705 ",(0,s.jsx)(r.strong,{children:"Validation"}),": Always test gravity, collisions, and motion before deployment"]}),"\n",(0,s.jsx)(r.hr,{}),"\n",(0,s.jsx)(r.h2,{id:"further-reading",children:"Further Reading"}),"\n",(0,s.jsxs)(r.ul,{children:["\n",(0,s.jsxs)(r.li,{children:["\ud83d\udcd6 ",(0,s.jsx)(r.a,{href:"http://sdformat.org/",children:"Gazebo SDF Specification"})]}),"\n",(0,s.jsxs)(r.li,{children:["\ud83d\udcd6 ",(0,s.jsx)(r.a,{href:"http://www.ode.org/wiki/index.php/Manual",children:"ODE Physics Tuning Guide"})]}),"\n",(0,s.jsxs)(r.li,{children:["\ud83d\udcd6 ",(0,s.jsx)(r.a,{href:"https://classic.gazebosim.org/tutorials?tut=ros2_urdf&cat=ign&ver=igni",children:"URDF to SDF Conversion"})]}),"\n",(0,s.jsxs)(r.li,{children:["\ud83d\udcd6 ",(0,s.jsx)(r.a,{href:"https://gazebosim.org/docs",children:"Humanoid Physics in Gazebo"})]}),"\n"]}),"\n",(0,s.jsx)(r.hr,{}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"Next Lesson"}),": ",(0,s.jsx)(r.a,{href:"/physical-ai-textbook/docs/chapter-2/2-3-sensors-unity",children:"Lesson 2.3: Sensor Simulation & Unity Integration"})]}),"\n",(0,s.jsxs)(r.p,{children:[(0,s.jsx)(r.strong,{children:"Questions?"})," See ",(0,s.jsx)(r.a,{href:"/physical-ai-textbook/docs/faq",children:"FAQ"})," or ",(0,s.jsx)(r.a,{href:"https://github.com/physical-ai-course/physical-ai-textbook/discussions",children:"GitHub Discussions"})]})]})}function h(n={}){const{wrapper:r}={...(0,t.R)(),...n.components};return r?(0,s.jsx)(r,{...n,children:(0,s.jsx)(d,{...n})}):d(n)}},8453:function(n,r,e){e.d(r,{R:function(){return o},x:function(){return l}});var i=e(6540);const s={},t=i.createContext(s);function o(n){const r=i.useContext(t);return i.useMemo(function(){return"function"==typeof n?n(r):{...r,...n}},[r,n])}function l(n){let r;return r=n.disableParentContext?"function"==typeof n.components?n.components(s):n.components||s:o(n.components),i.createElement(t.Provider,{value:r},n.children)}}}]);